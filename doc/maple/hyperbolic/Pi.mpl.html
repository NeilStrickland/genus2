<html>
 <head>
 </head>
 <body>
  <pre>
    <a name="line_1"></a># This file defines the group Pi generated by beta[0],...,beta[7] 
<a name="line_2"></a># (with indices read modulo 8) subject to relations beta[i] beta[i+4] = 1 
<a name="line_3"></a># and beta[0] beta[1] beta[2] beta[3] beta[4] beta[5] beta[6] beta[7] = 1 
<a name="line_4"></a>
<a name="line_5"></a># Elements of Pi are represented as lists of integers.  For example,
<a name="line_6"></a># [1,3,0] represents beta[1] o beta[3] o beta[0].  We allow indices
<a name="line_7"></a># outside {0,..,7} with the understanding that beta[i] = beta[i mod 8].
<a name="line_8"></a>
<a name="line_9"></a><span style="color:red">#@ `type/Pi_element`
</span><a name="line_10"></a>`type/Pi_element` := (L) -> type(L,list(integer));
<a name="line_11"></a>
<a name="line_12"></a># We say that a word in the generators beta[i] is reduced if it contains 
<a name="line_13"></a># no subwords beta[i] beta[i+4], no decreasing runs of length at least 4,
<a name="line_14"></a># and no increasing runs of length at least 5.  The following function 
<a name="line_15"></a># checks whether a word (represented as a list of integers) is reduced.
<a name="line_16"></a>
<a name="line_17"></a><span style="color:red">#@ is_Pi_reduced
</span><a name="line_18"></a>is_Pi_reduced := proc(L::Pi_element)
<a name="line_19"></a> local n,i,run_length,run_direction;
<a name="line_20"></a> n := nops(L);
<a name="line_21"></a> for i from 1 to n do
<a name="line_22"></a>  if L[i] < 0 or L[i] > 7 then
<a name="line_23"></a>   return(false);
<a name="line_24"></a>  fi;
<a name="line_25"></a> od;
<a name="line_26"></a> if n <= 1 then
<a name="line_27"></a>  return(true);
<a name="line_28"></a> fi;
<a name="line_29"></a> for i from 1 to n-1 do
<a name="line_30"></a>  if modp(L[i+1]-L[i]+4,8) = 0 then
<a name="line_31"></a>   return(false);
<a name="line_32"></a>  fi;
<a name="line_33"></a> od;
<a name="line_34"></a> run_length := 0;
<a name="line_35"></a> run_direction := 0;
<a name="line_36"></a> for i from 2 to n do
<a name="line_37"></a>  if run_direction = 0 then
<a name="line_38"></a>   if mods(L[i]-L[i-1],8) = 1 then
<a name="line_39"></a>    run_direction := 1;
<a name="line_40"></a>    run_length := 2;
<a name="line_41"></a>   elif mods(L[i]-L[i-1],8) = -1 then
<a name="line_42"></a>    run_direction := -1;
<a name="line_43"></a>    run_length := 2;
<a name="line_44"></a>   fi; 
<a name="line_45"></a>  else 
<a name="line_46"></a>   if mods(L[i]-L[i-1]-run_direction,8) = 0 then
<a name="line_47"></a>    run_length := run_length+1;
<a name="line_48"></a>    if run_length >=4 and (run_direction = -1 or run_length > 4) then
<a name="line_49"></a>     return(false);
<a name="line_50"></a>    fi;
<a name="line_51"></a>   else
<a name="line_52"></a>    run_length := 0;
<a name="line_53"></a>    run_direction := 0;
<a name="line_54"></a>   fi;
<a name="line_55"></a>  fi;
<a name="line_56"></a> od:
<a name="line_57"></a> return(true);
<a name="line_58"></a>end; 
<a name="line_59"></a>
<a name="line_60"></a># The function Pi_reduce_once eliminates any subwords of the form 
<a name="line_61"></a># beta[i] beta[i+4], then removes the first inadmissable run that 
<a name="line_62"></a># it finds.  It returns a word that represents the same element of
<a name="line_63"></a># Pi as the original word supplied as an argument, but that is 
<a name="line_64"></a># closer to being reduced.
<a name="line_65"></a>
<a name="line_66"></a><span style="color:red">#@ Pi_reduce_once
</span><a name="line_67"></a>Pi_reduce_once := proc(L::Pi_element)
<a name="line_68"></a> local n,i,run_length,run_direction,R;
<a name="line_69"></a> n := nops(L);
<a name="line_70"></a> if n = 0 then
<a name="line_71"></a>  return([]);
<a name="line_72"></a> fi;
<a name="line_73"></a>
<a name="line_74"></a> R := [];
<a name="line_75"></a> for i from 1 to n do
<a name="line_76"></a>  if R <> [] and modp(L[i]-R[-1]-4,8)=0 then
<a name="line_77"></a>   R := R[1..-2];
<a name="line_78"></a>  else
<a name="line_79"></a>   R := [op(R),modp(L[i],8)];
<a name="line_80"></a>  fi;
<a name="line_81"></a> od;
<a name="line_82"></a> if nops(R) <= 1 then
<a name="line_83"></a>  return(R);
<a name="line_84"></a> fi;
<a name="line_85"></a> n := nops(R);
<a name="line_86"></a> run_length := 0;
<a name="line_87"></a> run_direction := 0;
<a name="line_88"></a> for i from 2 to n do
<a name="line_89"></a>  if run_direction = 0 then
<a name="line_90"></a>   if mods(R[i]-R[i-1],8) = 1 then
<a name="line_91"></a>    run_direction := 1;
<a name="line_92"></a>    run_length := 2;
<a name="line_93"></a>   elif mods(R[i]-R[i-1],8) = -1 then
<a name="line_94"></a>    run_direction := -1;
<a name="line_95"></a>    run_length := 2;
<a name="line_96"></a>   fi; 
<a name="line_97"></a>  else 
<a name="line_98"></a>   if mods(R[i]-R[i-1]-run_direction,8) = 0 then
<a name="line_99"></a>    run_length := run_length+1;
<a name="line_100"></a>    if run_length >=4 and (run_direction = -1 or run_length > 4) then
<a name="line_101"></a>     return([seq(R[j],j=1..i-run_length),
<a name="line_102"></a>             seq(modp(R[i+1-run_length]+(4-j)*run_direction,8),j=1..8-run_length),
<a name="line_103"></a>             seq(R[j],j=i+1..n)]);
<a name="line_104"></a>    fi;
<a name="line_105"></a>   else
<a name="line_106"></a>    run_length := 0;
<a name="line_107"></a>    run_direction := 0;
<a name="line_108"></a>   fi;
<a name="line_109"></a>  fi;
<a name="line_110"></a> od:
<a name="line_111"></a> return(R);
<a name="line_112"></a>end; 
<a name="line_113"></a>
<a name="line_114"></a># The function Pi_reduce applies Pi_reduce_once repeatedly to find
<a name="line_115"></a># the unique reduced word representing the same element of Pi as the 
<a name="line_116"></a># argument.
<a name="line_117"></a>
<a name="line_118"></a><span style="color:red">#@ Pi_reduce
</span><a name="line_119"></a>Pi_reduce := proc(L)
<a name="line_120"></a> local M,N;
<a name="line_121"></a> M := L;
<a name="line_122"></a> N := Pi_reduce_once(M);
<a name="line_123"></a> while (M <> N) do
<a name="line_124"></a>  M := N;
<a name="line_125"></a>  N := Pi_reduce_once(M);
<a name="line_126"></a> od:
<a name="line_127"></a> return(N);
<a name="line_128"></a>end;
<a name="line_129"></a>
<a name="line_130"></a># Pi_mult is the multiplication function for the group Pi.
<a name="line_131"></a># It concatenates its arguments to produce a (possibly unreduced)
<a name="line_132"></a># word, and then reduces it.
<a name="line_133"></a>
<a name="line_134"></a><span style="color:red">#@ Pi_mult
</span><a name="line_135"></a>Pi_mult := proc() Pi_reduce(map(op,[args])); end;
<a name="line_136"></a>
<a name="line_137"></a># Pi_inv returns the inverse of a word in Pi.
<a name="line_138"></a>
<a name="line_139"></a><span style="color:red">#@ Pi_inv
</span><a name="line_140"></a>Pi_inv := proc(L)
<a name="line_141"></a> local n,i;
<a name="line_142"></a> n := nops(L);
<a name="line_143"></a> [seq(modp(L[-i]+4,8),i=1..n)];
<a name="line_144"></a>end;
<a name="line_145"></a>
<a name="line_146"></a># An alternative system of generators alpha[j]
<a name="line_147"></a>
<a name="line_148"></a><span style="color:red">#@ Pi_alpha
</span><a name="line_149"></a>Pi_alpha[0] := [7,6,0]:
<a name="line_150"></a>Pi_alpha[1] := [1,2,3]:
<a name="line_151"></a>Pi_alpha[2] := [6]:
<a name="line_152"></a>Pi_alpha[3] := [7]:
<a name="line_153"></a>
<a name="line_154"></a># The original generators beta[i] in terms of the alpha[j]
<a name="line_155"></a>
<a name="line_156"></a><span style="color:red">#@ Pi_beta_alpha
</span><a name="line_157"></a>Pi_beta_alpha[0] := [-2,-3, 0];
<a name="line_158"></a>Pi_beta_alpha[1] := [ 1, 3, 2];
<a name="line_159"></a>Pi_beta_alpha[2] := [-2];
<a name="line_160"></a>Pi_beta_alpha[3] := [-3];
<a name="line_161"></a>
<a name="line_162"></a># Another alternative system of generators sigma[t]
<a name="line_163"></a>
<a name="line_164"></a><span style="color:red">#@ Pi_sigma_beta
</span><a name="line_165"></a>Pi_sigma_beta["a"] := [5,6];
<a name="line_166"></a>Pi_sigma_beta["b"] := [2];
<a name="line_167"></a>Pi_sigma_beta["c"] := [7,0];
<a name="line_168"></a>Pi_sigma_beta["d"] := [4];
<a name="line_169"></a>Pi_sigma_beta["e"] := [1,2];
<a name="line_170"></a>Pi_sigma_beta["f"] := [3,4];
<a name="line_171"></a>
<a name="line_172"></a>for i in ["a","b","c","d","e","f"] do
<a name="line_173"></a> Pi_sigma_beta[i, 1] := Pi_sigma_beta[i];
<a name="line_174"></a> Pi_sigma_beta[i,-1] := Pi_inv(Pi_sigma_beta[i]);
<a name="line_175"></a>od:
<a name="line_176"></a>
<a name="line_177"></a># The original generators beta[i] in terms of the sigma[t]
<a name="line_178"></a>
<a name="line_179"></a><span style="color:red">#@ Pi_beta_sigma
</span><a name="line_180"></a>Pi_beta_sigma[0] := [["d",-1]];
<a name="line_181"></a>Pi_beta_sigma[1] := [["e", 1],["b",-1]];
<a name="line_182"></a>Pi_beta_sigma[2] := [["b", 1]];
<a name="line_183"></a>Pi_beta_sigma[3] := [["f", 1],["d",-1]];
<a name="line_184"></a>Pi_beta_sigma[4] := [["d", 1]];
<a name="line_185"></a>Pi_beta_sigma[5] := [["b", 1],["e",-1]];
<a name="line_186"></a>Pi_beta_sigma[6] := [["b",-1]];
<a name="line_187"></a>Pi_beta_sigma[7] := [["d", 1],["f",-1]];
<a name="line_188"></a>
<a name="line_189"></a># If L is a reduced word in Pi, then Pi_reduced_extensions(L)
<a name="line_190"></a># is the sequence of all reduced words that can be obtained by 
<a name="line_191"></a># adding an extra letter to the end of L
<a name="line_192"></a>
<a name="line_193"></a><span style="color:red">#@ Pi_reduced_extensions
</span><a name="line_194"></a>Pi_reduced_extensions := proc(L::Pi_element)
<a name="line_195"></a> local n,A,B;
<a name="line_196"></a> n := nops(L);
<a name="line_197"></a> A := {0,1,2,3,4,5,6,7};
<a name="line_198"></a> if (n = 0) then
<a name="line_199"></a>  return(seq([i],i=0..7));
<a name="line_200"></a> fi;
<a name="line_201"></a> A := A minus {modp(L[n]+4,8)};
<a name="line_202"></a> if n >= 3 and
<a name="line_203"></a>  modp(L[n-1]-L[n  ],8) = 1 and
<a name="line_204"></a>  modp(L[n-2]-L[n-1],8) = 1 then
<a name="line_205"></a>  A := A minus {modp(L[n]-1,8)};
<a name="line_206"></a> elif n >= 4 and
<a name="line_207"></a>  modp(L[n  ]-L[n-1],8) = 1 and
<a name="line_208"></a>  modp(L[n-1]-L[n-2],8) = 1 and
<a name="line_209"></a>  modp(L[n-2]-L[n-3],8) = 1 then
<a name="line_210"></a>  A := A minus {modp(L[n]+1,8)};
<a name="line_211"></a> fi;
<a name="line_212"></a> A := sort([op(A)]);
<a name="line_213"></a> seq([op(L),A[i]],i=1..nops(A));
<a name="line_214"></a>end;
<a name="line_215"></a>
<a name="line_216"></a># Pi_words(m) is the list of all reduced words of length precisely m.
<a name="line_217"></a><span style="color:red">#@ Pi_words
</span><a name="line_218"></a>Pi_words := proc(m::nonnegint)
<a name="line_219"></a> option remember;
<a name="line_220"></a> if m = 0 then
<a name="line_221"></a>  return([[]]);
<a name="line_222"></a> else
<a name="line_223"></a>  return (map(Pi_reduced_extensions,Pi_words(m-1)));
<a name="line_224"></a> fi;
<a name="line_225"></a>end;
<a name="line_226"></a>
<a name="line_227"></a># Pi_words_leq(m) is the list of all reduced words of length at most m.
<a name="line_228"></a><span style="color:red">#@ Pi_words_leq
</span><a name="line_229"></a>Pi_words_leq := proc(m::nonnegint)
<a name="line_230"></a> map(op,[seq(Pi_words(k),k=0..m)]);
<a name="line_231"></a>end;
<a name="line_232"></a>
<a name="line_233"></a># Pi_word_band(k) is a subset of Pi, starting with Pi_word_band(0)={1}.
<a name="line_234"></a># If we put
<a name="line_235"></a># A(k) = union of translates of F1 under Pi_word_band(j) with j <= k
<a name="line_236"></a># then A(k) is contained in the interior of A(k+1).
<a name="line_237"></a>
<a name="line_238"></a><span style="color:red">#@ Pi_word_band
</span><a name="line_239"></a>Pi_word_band := proc(k)
<a name="line_240"></a> option remember;
<a name="line_241"></a> local B,L,M,j;
<a name="line_242"></a>
<a name="line_243"></a> if k = 0 then
<a name="line_244"></a>  return([[]]);
<a name="line_245"></a> elif k = 1 then 
<a name="line_246"></a>  return ([
<a name="line_247"></a>   [0],[1],[2],[3],[4],[5],[6],[7],
<a name="line_248"></a>   [0,7],[1,2],[2,1],[3,4],[4,3],[5,6],[6,5],[7,0],
<a name="line_249"></a>   [0,7,0],[2,1,2],[4,3,4],[6,5,6],
<a name="line_250"></a>   [1,2,3,4],[3,4,5,6],[5,6,7,0],[7,0,1,2]
<a name="line_251"></a>  ]):
<a name="line_252"></a> else
<a name="line_253"></a>  B := {seq(seq(Pi_mult(L,M),
<a name="line_254"></a>                L in Pi_word_band(1)),
<a name="line_255"></a>                M in Pi_word_band(k-1))}
<a name="line_256"></a>        minus {seq(op(Pi_word_band[j]),j=0..k-1)}:
<a name="line_257"></a>  B := [op(B)];
<a name="line_258"></a>  return(B);
<a name="line_259"></a> fi;
<a name="line_260"></a>end;
<a name="line_261"></a>
<a name="line_262"></a><span style="color:red">#@ Pi_word_block
</span><a name="line_263"></a>Pi_word_block := proc(k)
<a name="line_264"></a> option remember;
<a name="line_265"></a> [seq(op(Pi_word_band(j)),j=0..k)];
<a name="line_266"></a>end;
<a name="line_267"></a>
<a name="line_268"></a># act_Pi(L,z) gives the action of the word L on a point z in the
<a name="line_269"></a># open unit disc.  This depends on the parameter a_H.
<a name="line_270"></a>
<a name="line_271"></a><span style="color:red">#@ act_Pi
</span><a name="line_272"></a>act_Pi := proc(L::Pi_element,z)
<a name="line_273"></a> local n,i,j,w;
<a name="line_274"></a> n := nops(L);
<a name="line_275"></a> w := z;
<a name="line_276"></a> for i from 0 to n-1 do
<a name="line_277"></a>  w := simplify(beta[L[n-i]](w));
<a name="line_278"></a> od;
<a name="line_279"></a> return(w);
<a name="line_280"></a>end;
<a name="line_281"></a>
<a name="line_282"></a># act_Pi0(L,z) and act_Pi1(L,z) are the same as 
<a name="line_283"></a># act_Pi(L,z) except that the numerical value a_H0 or
<a name="line_284"></a># a_H1 = evalf(a_H0) is substituted for the symbolic a_H.
<a name="line_285"></a>
<a name="line_286"></a><span style="color:red">#@ act_Pi0
</span><a name="line_287"></a>act_Pi0 := proc(L::Pi_element,z)
<a name="line_288"></a> local n,i,j,w;
<a name="line_289"></a> n := nops(L);
<a name="line_290"></a> w := z;
<a name="line_291"></a> for i from 0 to n-1 do
<a name="line_292"></a>  w := simplify(beta0[L[n-i]](w));
<a name="line_293"></a> od;
<a name="line_294"></a> return(w);
<a name="line_295"></a>end;
<a name="line_296"></a>
<a name="line_297"></a><span style="color:red">#@ act_Pi1
</span><a name="line_298"></a>act_Pi1 := proc(L::Pi_element,z)
<a name="line_299"></a> local n,i,j,w;
<a name="line_300"></a> n := nops(L);
<a name="line_301"></a> w := z;
<a name="line_302"></a> for i from 0 to n-1 do
<a name="line_303"></a>  w := simplify(beta1[L[n-i]](w));
<a name="line_304"></a> od;
<a name="line_305"></a> return(w);
<a name="line_306"></a>end;
<a name="line_307"></a>
<a name="line_308"></a># This is organised to be more efficient than act_Pi1
<a name="line_309"></a>
<a name="line_310"></a><span style="color:red">#@ act_Pi1_map
</span><a name="line_311"></a>act_Pi1_map := proc(L::Pi_element)
<a name="line_312"></a> option remember;
<a name="line_313"></a> local z,zz,zd,zn,dd,ff;
<a name="line_314"></a>
<a name="line_315"></a> if L = [] then
<a name="line_316"></a>  return((z) -> z);
<a name="line_317"></a> else
<a name="line_318"></a>  zz := simplify(beta1[L[1]](act_Pi1_map(L[2..-1])(z))):
<a name="line_319"></a>  zd := denom(zz):
<a name="line_320"></a>  zn := numer(zz):
<a name="line_321"></a>  dd := sqrt(abs(coeff(zn,z,0))^2 + abs(coeff(zn,z,1))^2 + abs(coeff(zd,z,0))^2 + abs(coeff(zd,z,1))^2);
<a name="line_322"></a>  zd := expand(zd/dd);
<a name="line_323"></a>  zn := expand(zn/dd);
<a name="line_324"></a>  zz := zn/zd;
<a name="line_325"></a>  return(unapply(zz,z));
<a name="line_326"></a> fi:
<a name="line_327"></a>end;
<a name="line_328"></a>
<a name="line_329"></a># Given an expression f of the form (a z + b)/(c z + d), 
<a name="line_330"></a># the function mobius_matrix(f,z) returns the matrix
<a name="line_331"></a># [[a,b],[c,d]]/r, where r is chosen to make the determinant
<a name="line_332"></a># equal to one.
<a name="line_333"></a>
<a name="line_334"></a><span style="color:red">#@ mobius_matrix
</span><a name="line_335"></a>mobius_matrix := proc(f,z)
<a name="line_336"></a> local ab,cd,a,b,c,d,rd;
<a name="line_337"></a> ab := numer(f);
<a name="line_338"></a> cd := denom(f);
<a name="line_339"></a> a := coeff(ab,z,1);
<a name="line_340"></a> b := coeff(ab,z,0);
<a name="line_341"></a> c := coeff(cd,z,1);
<a name="line_342"></a> d := coeff(cd,z,0);
<a name="line_343"></a> rd := sqrt(a*d - b*c);
<a name="line_344"></a> a := a/rd;
<a name="line_345"></a> b := b/rd;
<a name="line_346"></a> c := c/rd;
<a name="line_347"></a> d := d/rd;
<a name="line_348"></a> return(<<a|b>,<c|d>>);
<a name="line_349"></a>end;
<a name="line_350"></a>
<a name="line_351"></a># Let M be a matrix in SL_2(C) representing a Mobius map that 
<a name="line_352"></a># preserves the unit disc.  Then SL2R_conjugate(M) returns a 
<a name="line_353"></a># matrix M1 in SL_2(R) that is conjugate to M.
<a name="line_354"></a>  
<a name="line_355"></a><span style="color:red">#@ SL2R_conjugate
</span><a name="line_356"></a>SL2R_conjugate := proc(M)
<a name="line_357"></a> local a,b,c,d,A,B,C,D,E;
<a name="line_358"></a>
<a name="line_359"></a> a,b,c,d := M[1,1],M[1,2],M[2,1],M[2,2];
<a name="line_360"></a> A := (  a - b - c + d)/2;
<a name="line_361"></a> B := (- a - b + c + d)/2*I;
<a name="line_362"></a> C := (  a - b + c - d)/2*I;
<a name="line_363"></a> D := (  a + b + c + d)/2;
<a name="line_364"></a> E := sqrt(A*D - B*C);
<a name="line_365"></a> A := Re(A/E); B := Re(B/E); C := Re(C/E); D := Re(D/E);
<a name="line_366"></a># A := A/E; B := B/E; C := C/E; D := D/E;
<a name="line_367"></a> return(<<A|B>,<C|D>>);
<a name="line_368"></a>end;
<a name="line_369"></a>
<a name="line_370"></a># Given a word L in Pi, the function act_Pi1_matrix(L) returns
<a name="line_371"></a># a matrix in SL_2(C) that implements the action of L on the unit disk.
<a name="line_372"></a>
<a name="line_373"></a><span style="color:red">#@ act_Pi1_matrix
</span><a name="line_374"></a>act_Pi1_matrix := proc(L::Pi_element)
<a name="line_375"></a> option remember;
<a name="line_376"></a> local z,zz,zd,zn,dd,ff;
<a name="line_377"></a>
<a name="line_378"></a> if L = [] then
<a name="line_379"></a>  return(<<1|0>,<0|1>>);
<a name="line_380"></a> else
<a name="line_381"></a>  return(beta1_matrix[L[1]] . act_Pi1_matrix(L[2..-1]));
<a name="line_382"></a> fi;
<a name="line_383"></a>end;
<a name="line_384"></a>
<a name="line_385"></a># beta_L_word[i] is the conjugate of beta[i] by lambda
<a name="line_386"></a>
<a name="line_387"></a><span style="color:red">#@ beta_L_word
</span><a name="line_388"></a>beta_L_word[0] := [2]:
<a name="line_389"></a>beta_L_word[1] := [3]:
<a name="line_390"></a>beta_L_word[2] := [4]:
<a name="line_391"></a>beta_L_word[3] := [5]:
<a name="line_392"></a>beta_L_word[4] := [6]:
<a name="line_393"></a>beta_L_word[5] := [7]:
<a name="line_394"></a>beta_L_word[6] := [0]:
<a name="line_395"></a>beta_L_word[7] := [1]:
<a name="line_396"></a>
<a name="line_397"></a># beta_M_word[i] is the conjugate of beta[i] by mu
<a name="line_398"></a>
<a name="line_399"></a><span style="color:red">#@ beta_M_word
</span><a name="line_400"></a>beta_M_word[0] := [2,0,1]:
<a name="line_401"></a>beta_M_word[1] := [5,4,3]:
<a name="line_402"></a>beta_M_word[2] := [0,7,6]:
<a name="line_403"></a>beta_M_word[3] := [2,3,1]:
<a name="line_404"></a>beta_M_word[4] := [5,4,6]:
<a name="line_405"></a>beta_M_word[5] := [7,0,1]:
<a name="line_406"></a>beta_M_word[6] := [2,3,4]:
<a name="line_407"></a>beta_M_word[7] := [5,7,6]:
<a name="line_408"></a>
<a name="line_409"></a># beta_N_word[i] is the conjugate of beta[i] by nu
<a name="line_410"></a>
<a name="line_411"></a><span style="color:red">#@ beta_N_word
</span><a name="line_412"></a>beta_N_word[0] := [0]:
<a name="line_413"></a>beta_N_word[1] := [2,1,2]:
<a name="line_414"></a>beta_N_word[2] := [6]:
<a name="line_415"></a>beta_N_word[3] := [0,7,0]:
<a name="line_416"></a>beta_N_word[4] := [4]:
<a name="line_417"></a>beta_N_word[5] := [6,5,6]:
<a name="line_418"></a>beta_N_word[6] := [2]:
<a name="line_419"></a>beta_N_word[7] := [4,3,4]:
<a name="line_420"></a>
<a name="line_421"></a># The function act_on_Pi gives the action of L, M and N on Pi 
<a name="line_422"></a># by conjugation in Pi_tilde
<a name="line_423"></a>
<a name="line_424"></a><span style="color:red">#@ act_on_Pi
</span><a name="line_425"></a>act_on_Pi[L] := proc(W::Pi_element)
<a name="line_426"></a> local W1;
<a name="line_427"></a> W1 := subs({seq(i = beta_L_word[i],i=0..7)},W);
<a name="line_428"></a> W1 := Pi_reduce(map(op,W1));
<a name="line_429"></a> return(W1);
<a name="line_430"></a>end;
<a name="line_431"></a>
<a name="line_432"></a>act_on_Pi[M] := proc(W::Pi_element)
<a name="line_433"></a> local W1;
<a name="line_434"></a> W1 := subs({seq(i = beta_M_word[i],i=0..7)},W);
<a name="line_435"></a> W1 := Pi_reduce(map(op,W1));
<a name="line_436"></a> return(W1);
<a name="line_437"></a>end;
<a name="line_438"></a>
<a name="line_439"></a>act_on_Pi[N] := proc(W::Pi_element)
<a name="line_440"></a> local W1;
<a name="line_441"></a> W1 := subs({seq(i = beta_N_word[i],i=0..7)},W);
<a name="line_442"></a> W1 := Pi_reduce(map(op,W1));
<a name="line_443"></a> return(W1);
<a name="line_444"></a>end;
<a name="line_445"></a>
<a name="line_446"></a># If T.U = V in G, then T.U = V.L in Pi_tilde for some L in Pi.
<a name="line_447"></a># The appropriate value of L is stored as G_Pi_cocycle[T,U].
<a name="line_448"></a>
<a name="line_449"></a><span style="color:red">#@ G_Pi_cocycle
</span><a name="line_450"></a>G_Pi_cocycle := table([(M,M)=[],(LLMN,LLLM)=[4,6],(LLMN,LLMN)=[1,2],(L,LLLM)=[],(N,LLL)=[],(LLLN,N)=[],(LL,M)=[],(LM,LLL)=[2,3],(LLN,LLLM)=[6,0,7,6],(LMN,MN)=[2,3,4,2],(1,N)=[],(LLL,LLL)=[],(LLM,1)=[],(LN,1)=[],(LLLM,LLMN)=[2,1,2,3,4,2],(LLLMN,LMN)=[3,2,1,2],(LLM,MN)=[],(MN,LN)=[2,3],(LL,LLM)=[],(LM,LM)=[7,6],(LLN,LLMN)=[2,3,4,2],(LMN,1)=[],(LLLN,LLMN)=[2,3,4,2],(L,LN)=[],(LLL,LM)=[],(N,LLLN)=[],(LLMN,LM)=[0,7,0,1],(M,LLLMN)=[0,2,1,2],(LLN,L)=[],(1,LLN)=[],(MN,LLL)=[6,5,6,4],(LLMN,N)=[],(LM,LLMN)=[2,1,2,3,4,2],(LLLM,1)=[],(LLLM,LLN)=[6,5,6,7,0,6],(L,LL)=[],(MN,LLLN)=[5,4],(LLL,LLLM)=[],(N,LN)=[],(LN,M)=[6,0,7,6],(LLMN,LLLN)=[5,4],(1,L)=[],(LMN,LLM)=[2,1],(1,M)=[],(M,LMN)=[4,3,4,2],(LLN,LLL)=[],(1,MN)=[],(LL,LLN)=[],(LM,LLN)=[6,5,6,7,0,6],(LN,LLM)=[6,0,7,6],(M,LL)=[2,3,4,5],(LLN,LM)=[6,0,7,6],(LMN,LLN)=[2,3,4,5],(LLLM,LM)=[7,6],(LLLMN,LM)=[0,7,0,1],(LLLM,N)=[],(LLLM,L)=[5,4],(L,LMN)=[],(LLM,LLN)=[6,5,6,7,0,6],(LLLM,LLL)=[2,3],(LLLMN,1)=[],(LMN,M)=[6,0,7,6],(LLLMN,LLLN)=[5,4],(N,LMN)=[2,3,4,2],(LMN,LN)=[2,3],(LLM,LL)=[2,3,4,5],(LLLMN,LLL)=[6,5,6,4],(L,M)=[],(M,N)=[],(LLN,LLN)=[],(LL,LLMN)=[],(LLLN,MN)=[2,3,4,2],(MN,LLM)=[2,1],(LMN,LL)=[6,5,6,7,0,6],(LL,1)=[],(LM,LLLM)=[0,1],(LLL,LMN)=[],(M,LN)=[6,5,6,4],(LMN,LLLMN)=[4,2],(LLLMN,L)=[6,0,7,0],(LLLM,MN)=[],(N,LLM)=[6,0,7,6],(LN,LL)=[],(LLN,1)=[],(MN,LMN)=[3,2,1,2],(LLL,LLN)=[],(1,LLL)=[],(LL,LL)=[],(LM,LN)=[6,5,6,4],(LN,LN)=[],(LL,MN)=[],(LLLN,LLN)=[],(LLMN,LLL)=[6,5,6,4],(LLLN,LM)=[6,0,7,6],(LLL,L)=[],(LLN,MN)=[2,3,4,2],(LLM,LLMN)=[2,1,2,3,4,2],(LLLMN,N)=[],(LLM,LLLM)=[0,1],(LN,LLMN)=[2,3,4,2],(LLMN,LLN)=[2,3,4,5],(L,LLLN)=[],(LLLM,LLLMN)=[0,2,1,2],(MN,L)=[6,0,7,0],(MN,LLLMN)=[4,2],(LLL,N)=[],(LLLM,LLM)=[6,7,0,1],(1,LLM)=[],(LM,MN)=[],(LLM,N)=[],(LLLN,LL)=[],(N,L)=[],(N,LLLMN)=[2,3,4,2],(LN,LLLN)=[],(1,LLLMN)=[],(LLLMN,LLLMN)=[4,2],(LLMN,L)=[6,0,7,0],(LL,LLLM)=[],(L,LLM)=[],(M,LLM)=[6,7,0,1],(LLL,LLLMN)=[],(M,LLLN)=[6,0,7,0],(LLLN,LLLMN)=[2,3,4,2],(L,MN)=[],(LM,1)=[],(LLN,LL)=[],(MN,M)=[6,0,7,6],(1,LMN)=[],(LM,LLLMN)=[0,2,1,2],(LLLMN,MN)=[2,3,4,2],(LLM,LM)=[7,6],(LLLN,LLLM)=[6,0,7,6],(LLM,LMN)=[4,3,4,2],(LLMN,LMN)=[3,2,1,2],(LL,LM)=[],(M,LLL)=[2,3],(LN,MN)=[2,3,4,2],(LMN,L)=[6,0,7,0],(LLLN,LMN)=[2,3,4,2],(LMN,LLLN)=[5,4],(LLL,M)=[],(LM,LL)=[2,3,4,5],(N,LLN)=[],(LLLMN,LLN)=[2,3,4,5],(LLL,LL)=[],(1,LLLN)=[],(LLM,M)=[],(LLM,L)=[5,4],(LN,L)=[],(1,LL)=[],(LLLM,LMN)=[4,3,4,2],(LL,LN)=[],(LLN,LMN)=[2,3,4,2],(LLLN,1)=[],(N,M)=[6,0,7,6],(LL,LLL)=[],(M,L)=[5,4],(L,LLN)=[],(LLN,N)=[],(LLLN,M)=[6,0,7,6],(LLMN,LLLMN)=[4,2],(LLLN,LLLN)=[],(LLMN,LL)=[6,5,6,7,0,6],(LLMN,LN)=[2,3],(LL,LLLN)=[],(N,N)=[],(LMN,LM)=[0,7,0,1],(MN,LLN)=[2,3,4,5],(LM,LLLN)=[6,0,7,0],(LN,LLLM)=[6,0,7,6],(1,1)=[],(LLN,LLLMN)=[2,3,4,2],(L,N)=[],(LMN,LLMN)=[1,2],(LLLMN,LLM)=[2,1],(LLN,LLM)=[6,0,7,6],(LLLM,LL)=[2,3,4,5],(LMN,LLLM)=[4,6],(L,LLMN)=[],(LLM,LLLN)=[6,0,7,0],(M,LLMN)=[2,1,2,3,4,2],(LLN,M)=[6,0,7,6],(LLL,MN)=[],(L,L)=[],(LLL,1)=[],(LLLM,M)=[],(LLMN,LLM)=[2,1],(LLLM,LN)=[6,5,6,4],(LLLN,LN)=[],(LLMN,M)=[6,0,7,6],(1,LLLM)=[],(LLL,LLM)=[],(LM,M)=[],(MN,N)=[],(LN,LM)=[6,0,7,6],(LLL,LLLN)=[],(LL,LLLMN)=[],(LM,N)=[],(LN,N)=[],(LLL,LLMN)=[],(L,LLLMN)=[],(MN,LLLM)=[4,6],(LLLMN,LL)=[6,5,6,7,0,6],(LLLM,LLLM)=[0,1],(LLLN,LLL)=[],(L,LLL)=[],(LLLM,LLLN)=[6,0,7,0],(LN,LLL)=[],(LN,LLLMN)=[2,3,4,2],(L,1)=[],(LLN,LLLN)=[],(M,LLLM)=[0,1],(LLN,LN)=[],(M,1)=[],(LM,LLM)=[6,7,0,1],(LMN,LLL)=[6,5,6,4],(M,LLN)=[6,5,6,7,0,6],(N,MN)=[2,3,4,2],(MN,MN)=[2,3,4,2],(LMN,N)=[],(LLLMN,LLLM)=[4,6],(1,LM)=[],(LLLMN,M)=[6,0,7,6],(N,LLLM)=[6,0,7,6],(1,LN)=[],(LL,N)=[],(M,LM)=[7,6],(M,MN)=[],(MN,1)=[],(LLM,LLM)=[6,7,0,1],(N,LL)=[],(LLMN,1)=[],(LLLMN,LN)=[2,3],(N,LLMN)=[2,3,4,2],(LLM,LLLMN)=[0,2,1,2],(N,LM)=[6,0,7,6],(LLLMN,LLMN)=[1,2],(MN,LL)=[6,5,6,7,0,6],(L,LM)=[],(LLLN,LLM)=[6,0,7,6],(LLL,LN)=[],(LLMN,MN)=[2,3,4,2],(LL,LMN)=[],(MN,LLMN)=[1,2],(LL,L)=[],(MN,LM)=[0,7,0,1],(LM,L)=[5,4],(LM,LMN)=[4,3,4,2],(LLM,LN)=[6,5,6,4],(LN,LLN)=[],(LLM,LLL)=[2,3],(LLLN,L)=[],(LN,LMN)=[2,3,4,2],(1,LLMN)=[],(N,1)=[],(LMN,LMN)=[3,2,1,2]]):
<a name="line_451"></a>
<a name="line_452"></a># If T is in G then beta[i] . T = T . L in Pi_tilde for some L in Pi.
<a name="line_453"></a># The appropriate value of L is stored as beta_G_twist[i,T]. 
<a name="line_454"></a>
<a name="line_455"></a><span style="color:red">#@ beta_G_twist
</span><a name="line_456"></a>beta_G_twist := table();
<a name="line_457"></a>for i from 0 to 7 do
<a name="line_458"></a> beta_G_twist[i,1]   := [i];
<a name="line_459"></a> beta_G_twist[i,L]   := [modp(i-2,8)];
<a name="line_460"></a> beta_G_twist[i,LL]  := [modp(i-4,8)];
<a name="line_461"></a> beta_G_twist[i,LLL] := [modp(i-6,8)];
<a name="line_462"></a>od:
<a name="line_463"></a>for i from 0 to 7 do
<a name="line_464"></a> beta_G_twist[i,M]    := beta_M_word[i]; 
<a name="line_465"></a> beta_G_twist[i,LM]   := beta_M_word[modp(i-2,8)]; 
<a name="line_466"></a> beta_G_twist[i,LLM]  := beta_M_word[modp(i-4,8)]; 
<a name="line_467"></a> beta_G_twist[i,LLLM] := beta_M_word[modp(i-6,8)]; 
<a name="line_468"></a> beta_G_twist[i,N]    := beta_N_word[i]; 
<a name="line_469"></a> beta_G_twist[i,LN]   := beta_N_word[modp(i-2,8)]; 
<a name="line_470"></a> beta_G_twist[i,LLN]  := beta_N_word[modp(i-4,8)]; 
<a name="line_471"></a> beta_G_twist[i,LLLN] := beta_N_word[modp(i-6,8)]; 
<a name="line_472"></a> beta_G_twist[i,MN]   := Pi_mult(op(map(p -> beta_N_word[p],beta_M_word[i])));
<a name="line_473"></a>od:
<a name="line_474"></a>for i from 0 to 7 do
<a name="line_475"></a> beta_G_twist[i,LMN]   := beta_G_twist[modp(i-2,8),MN];
<a name="line_476"></a> beta_G_twist[i,LLMN]  := beta_G_twist[modp(i-4,8),MN];
<a name="line_477"></a> beta_G_twist[i,LLLMN] := beta_G_twist[modp(i-6,8),MN];
<a name="line_478"></a>od:
<a name="line_479"></a>
<a name="line_480"></a># Elements of Pi_tilde are represented by pairs [T,L], where T is in G16
<a name="line_481"></a># and L is a list of integers representing an element of Pi
<a name="line_482"></a>
<a name="line_483"></a><span style="color:red">#@ `type/Pi_tilde_element`
</span><a name="line_484"></a>`type/Pi_tilde_element` := (TL) ->
<a name="line_485"></a> type(TL,list) and nops(TL) = 2 and member(TL[1],G16) and type(TL[2],Pi_element); 
<a name="line_486"></a>
<a name="line_487"></a># The identity element in Pi_tilde
<a name="line_488"></a><span style="color:red">#@ Pi_tilde_id
</span><a name="line_489"></a>Pi_tilde_id := [1,[]]:
<a name="line_490"></a>
<a name="line_491"></a># The multiplication function for Pi_tilde. 
<a name="line_492"></a># It accepts an arbitrary number of arguments.
<a name="line_493"></a>
<a name="line_494"></a><span style="color:red">#@ Pi_tilde_mult
</span><a name="line_495"></a>Pi_tilde_mult := proc()
<a name="line_496"></a> local T0,L0,T1,L1,T2,L2;
<a name="line_497"></a> if nargs = 0 then
<a name="line_498"></a>  return [1,[]];
<a name="line_499"></a> elif nargs = 1 then
<a name="line_500"></a>  return args[1];
<a name="line_501"></a> else
<a name="line_502"></a>  T0,L0 := op(args[1]);
<a name="line_503"></a>  T1,L1 := op(args[2]);
<a name="line_504"></a>  T2 := G_mult(T0,T1);
<a name="line_505"></a>  L2 := Pi_mult(G_Pi_cocycle[T0,T1],op(map(i -> beta_G_twist[i,T1],L0)),L1);
<a name="line_506"></a>  if nargs = 2 then
<a name="line_507"></a>   return [T2,L2];
<a name="line_508"></a>  else
<a name="line_509"></a>   return Pi_tilde_mult([T2,L2],args[3..-1]);
<a name="line_510"></a>  fi;
<a name="line_511"></a> fi;
<a name="line_512"></a>end:
<a name="line_513"></a>
<a name="line_514"></a># The inversion function for Pi_tilde
<a name="line_515"></a>
<a name="line_516"></a><span style="color:red">#@ Pi_tilde_inv
</span><a name="line_517"></a>Pi_tilde_inv := proc(A0::Pi_tilde_element)
<a name="line_518"></a> local T0,L0,T1,L1,T2,L2;
<a name="line_519"></a> T0,L0 := op(A0);
<a name="line_520"></a> T1 := G_inv(T0);
<a name="line_521"></a> Pi_tilde_mult([1,Pi_inv(L0)],[T1,Pi_inv(G_Pi_cocycle[T0,T1])]);
<a name="line_522"></a>end:
<a name="line_523"></a>
<a name="line_524"></a># Action of Pi_tilde on the unit disk
<a name="line_525"></a>
<a name="line_526"></a><span style="color:red">#@ act_Pi_tilde
</span><a name="line_527"></a>act_Pi_tilde := proc(A0::Pi_tilde_element,z::CC)
<a name="line_528"></a> local T0,L0;
<a name="line_529"></a> T0,L0 := op(A0);
<a name="line_530"></a>
<a name="line_531"></a> act_H[T0](act_Pi(L0,z));
<a name="line_532"></a>end:
<a name="line_533"></a>
<a name="line_534"></a># Action of Pi_tilde on the unit disk (numeric version)
<a name="line_535"></a>
<a name="line_536"></a><span style="color:red">#@ act_Pi_tilde0
</span><a name="line_537"></a>act_Pi_tilde0 := proc(A0::Pi_tilde_element,z::CC1)
<a name="line_538"></a> local T0,L0;
<a name="line_539"></a> T0,L0 := op(A0);
<a name="line_540"></a>
<a name="line_541"></a> act_H0[T0](act_Pi0(L0,z));
<a name="line_542"></a>end:
<a name="line_543"></a>
<a name="line_544"></a># Reflections across walls of F16
<a name="line_545"></a><span style="color:red">#@ Pi_tilde_s
</span><a name="line_546"></a>Pi_tilde_s[0] := [MN,[6]];
<a name="line_547"></a>Pi_tilde_s[1] := [LN,[]];
<a name="line_548"></a>Pi_tilde_s[3] := [LLN,[4]];
<a name="line_549"></a>Pi_tilde_s[5] := [N,[]];
<a name="line_550"></a>
<a name="line_551"></a># Generators of Pi_tilde as words in the reflections
<a name="line_552"></a><span style="color:red">#@ G_s_word
</span><a name="line_553"></a>G_s_word[1]     := [];
<a name="line_554"></a>G_s_word[L]     := [1,5];
<a name="line_555"></a>G_s_word[LL]    := [1,5,1,5];
<a name="line_556"></a>G_s_word[LLL]   := [5,1];
<a name="line_557"></a>G_s_word[M]     := [1,5,3,5,1,0];
<a name="line_558"></a>G_s_word[LM]    := [1,5,1,5,3,5,1,0];
<a name="line_559"></a>G_s_word[LLM]   := [5,1,3,5,1,0];
<a name="line_560"></a>G_s_word[LLLM]  := [3,5,1,0];
<a name="line_561"></a>G_s_word[N]     := [5];
<a name="line_562"></a>G_s_word[LN]    := [1];
<a name="line_563"></a>G_s_word[LLN]   := [1,5,1];
<a name="line_564"></a>G_s_word[LLLN]  := [5,1,5];
<a name="line_565"></a>G_s_word[MN]    := [1,5,3,5,1,0,5];
<a name="line_566"></a>G_s_word[LMN]   := [1,5,1,5,3,5,1,0,5];
<a name="line_567"></a>G_s_word[LLMN]  := [5,1,3,5,1,0,5];
<a name="line_568"></a>G_s_word[LLLMN] := [3,5,1,0,5];
<a name="line_569"></a>
<a name="line_570"></a><span style="color:red">#@ beta_s_word
</span><a name="line_571"></a>beta_s_word[0] := [3,1,5,1];
<a name="line_572"></a>beta_s_word[1] := [5,1,5,0,3,5,1,0];
<a name="line_573"></a>beta_s_word[2] := [1,5,3,5,1,5];
<a name="line_574"></a>beta_s_word[3] := [5,0,3,5,1,0,5,1];
<a name="line_575"></a>beta_s_word[4] := [1,5,1,3];
<a name="line_576"></a>beta_s_word[5] := [0,1,5,3,0,5,1,5];
<a name="line_577"></a>beta_s_word[6] := [5,1,5,3,5,1];
<a name="line_578"></a>beta_s_word[7] := [1,5,0,1,5,3,0,5];
<a name="line_579"></a>
<a name="line_580"></a>
<a name="line_581"></a>######################################################################
<a name="line_582"></a>
<a name="line_583"></a># Given an expression p involving a_H  and z, this tries to find an 
<a name="line_584"></a># element L in Pi which sends z to p.
<a name="line_585"></a>
<a name="line_586"></a><span style="color:red">#@ find_Pi_word
</span><a name="line_587"></a>find_Pi_word := proc(p,max_length_) 
<a name="line_588"></a> local max_length,err,found,i,L;
<a name="line_589"></a>
<a name="line_590"></a> max_length := `if`(nargs > 1,max_length,5);
<a name="line_591"></a> for i from 0 to max_length do
<a name="line_592"></a>  for L in Pi_words(i) do
<a name="line_593"></a>   err := simplify(p - act_Pi(L,z));
<a name="line_594"></a>   if err = 0 then
<a name="line_595"></a>    return(L);
<a name="line_596"></a>   fi;
<a name="line_597"></a>  od;
<a name="line_598"></a> od;
<a name="line_599"></a>
<a name="line_600"></a> return FAIL;
<a name="line_601"></a>end;
<a name="line_602"></a>
<a name="line_603"></a># Given expressions p and q involving a_H, this tries to find an 
<a name="line_604"></a># element L in Pi which sends p to q.
<a name="line_605"></a>
<a name="line_606"></a><span style="color:red">#@ find_Pi_word_points
</span><a name="line_607"></a>find_Pi_word_points := proc(p,q,max_length_) 
<a name="line_608"></a> local max_length,err,found,i,L;
<a name="line_609"></a>
<a name="line_610"></a> max_length := `if`(nargs > 2,max_length,5);
<a name="line_611"></a> for i from 0 to max_length do
<a name="line_612"></a>  for L in Pi_words(i) do
<a name="line_613"></a>   err := simplify(q - act_Pi(L,p));
<a name="line_614"></a>   if err = 0 then
<a name="line_615"></a>    return(L);
<a name="line_616"></a>   fi;
<a name="line_617"></a>  od;
<a name="line_618"></a> od;
<a name="line_619"></a>
<a name="line_620"></a> return FAIL;
<a name="line_621"></a>end;
<a name="line_622"></a>
<a name="line_623"></a># Given complex numbers p and q, this tries to find an element L in Pi which
<a name="line_624"></a># sends p to q (where the action is determined by the numerical parameter a_H0).
<a name="line_625"></a>
<a name="line_626"></a><span style="color:red">#@ find_Pi_word_points0
</span><a name="line_627"></a>find_Pi_word_points0 := proc(p,q,max_length_,tolerance_) 
<a name="line_628"></a> local max_length,tolerance,p1,q1,err,found,i,L;
<a name="line_629"></a>
<a name="line_630"></a> max_length := `if`(nargs > 2,max_length_,5);
<a name="line_631"></a> tolerance := `if`(nargs > 3,tolerance_,10.^(-8));
<a name="line_632"></a>
<a name="line_633"></a> p1 := evalf(subs(a_H = a_H1,p));
<a name="line_634"></a> q1 := evalf(subs(a_H = a_H1,q));
<a name="line_635"></a>
<a name="line_636"></a> for i from 0 to max_length do
<a name="line_637"></a>  for L in Pi_words(i) do
<a name="line_638"></a>   err := q1 - act_Pi1(L,p1);
<a name="line_639"></a>   if abs(err) < tolerance then
<a name="line_640"></a>    return(L);
<a name="line_641"></a>   fi;
<a name="line_642"></a>  od;
<a name="line_643"></a> od;
<a name="line_644"></a>
<a name="line_645"></a> return FAIL;
<a name="line_646"></a>end;
<a name="line_647"></a>
<a name="line_648"></a>
  </pre>
 </body>
</html>
    
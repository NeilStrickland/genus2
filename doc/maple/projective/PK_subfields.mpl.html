<html>
 <head>
 </head>
 <body>
  <pre>
    <a name="line_1"></a>`Class/Declare`(
<a name="line_2"></a> "PK_subfield",
<a name="line_3"></a> "An instance of this class represents a subfield of the field $PK$ of functions on $PX(a)$ generated by the functions $w$ and $z$",
<a name="line_4"></a>
<a name="line_5"></a> ["Field","stabiliser"::list,"The list of elements of the group $G_{16}$ that act as the identity on this subfield"],
<a name="line_6"></a> ["Field","generating_sets"::list,"A list of generating sets for the subfield"],
<a name="line_7"></a> ["Field","conversion_rules"::table,"In the $(i,j)$ slot this should have a list of equations expressing the elements of generating set $i$ in terms of generating set $j$.  The $(i,i)$ slots can be left unset."],
<a name="line_8"></a>
<a name="line_9"></a> ["Method","check_stabiliser","",
<a name="line_10"></a>  proc(this)
<a name="line_11"></a>   local A,B,F,a,T,err,H;
<a name="line_12"></a>
<a name="line_13"></a>   A := {op(map(op,this["generating_sets"]))};
<a name="line_14"></a>   F := table():
<a name="line_15"></a>
<a name="line_16"></a>   for a in A do
<a name="line_17"></a>    for T in G8 do
<a name="line_18"></a>     err := simplify(act_PK[T](a) - a);
<a name="line_19"></a>     F[a,T] := evalb(err = 0);
<a name="line_20"></a>    od;
<a name="line_21"></a>   od;
<a name="line_22"></a>
<a name="line_23"></a>   for a in A do
<a name="line_24"></a>    for T in this["stabiliser"] do 
<a name="line_25"></a>     if not(F[a,T]) then
<a name="line_26"></a>      printf("%A is not fixed by %A\n",a,T);
<a name="line_27"></a>      return false;
<a name="line_28"></a>     fi;
<a name="line_29"></a>    od;
<a name="line_30"></a>   od;
<a name="line_31"></a>
<a name="line_32"></a>   for B in this["generating_sets"] do
<a name="line_33"></a>    H := select(T -> (map(a -> F[a,T],{op(B)}) = {true}),G8);
<a name="line_34"></a>    if H <> this["stabiliser"] then
<a name="line_35"></a>     printf("stabiliser(%A) = %A\n",B,H);
<a name="line_36"></a>     return false;
<a name="line_37"></a>    fi;
<a name="line_38"></a>   od:
<a name="line_39"></a>
<a name="line_40"></a>   return true;
<a name="line_41"></a>  end
<a name="line_42"></a> ],
<a name="line_43"></a>
<a name="line_44"></a> ["Method","check_conversion","",
<a name="line_45"></a>  proc(this)
<a name="line_46"></a>   local i,j,n,A,B,C,R,E,e,err;
<a name="line_47"></a>
<a name="line_48"></a>   A := this["generating_sets"];
<a name="line_49"></a>   n := nops(A);
<a name="line_50"></a>   R := eval(this["conversion_rules"]);
<a name="line_51"></a>   for i from 1 to n do
<a name="line_52"></a>    for j from 1 to n do
<a name="line_53"></a>     if i <> j then
<a name="line_54"></a>      B := A[i]; 
<a name="line_55"></a>      C := A[j];
<a name="line_56"></a>      E := R[i,j];
<a name="line_57"></a>      if not(type(E,list(equation))) then
<a name="line_58"></a>       printf("rule (%d,%d) is not a list of equations \n",i,j);
<a name="line_59"></a>       return false;
<a name="line_60"></a>      fi;
<a name="line_61"></a>      if {op(map(lhs,E))} <> {op(B)} then
<a name="line_62"></a>       printf("rule (%d,%d) is not a list of equations for generating set %d\n",i,j,i);
<a name="line_63"></a>       return false;
<a name="line_64"></a>      fi;
<a name="line_65"></a>      if indets({op(map(rhs,E))}) minus {op(C)} <> {} then
<a name="line_66"></a>       printf("rule (%d,%d) does not express generating set %d in terms of generating set %d\n",i,j,i,j);
<a name="line_67"></a>       return false;
<a name="line_68"></a>      fi;
<a name="line_69"></a>
<a name="line_70"></a>      for e in E do 
<a name="line_71"></a>       if not(PK_check_zero(lhs(e) - rhs(e))) then
<a name="line_72"></a>        printf("in rule (%d,%d), equation %A is incorrect\n",i,j,e);
<a name="line_73"></a>        return false;
<a name="line_74"></a>       fi;
<a name="line_75"></a>      od;
<a name="line_76"></a>     fi;
<a name="line_77"></a>    od;
<a name="line_78"></a>   od;
<a name="line_79"></a>
<a name="line_80"></a>   return true;
<a name="line_81"></a>  end
<a name="line_82"></a> ],
<a name="line_83"></a>
<a name="line_84"></a> ["Method","check","",
<a name="line_85"></a>  proc(this)
<a name="line_86"></a>   this["check_stabiliser"] and this["check_conversion"];
<a name="line_87"></a>  end
<a name="line_88"></a> ]
<a name="line_89"></a>):
<a name="line_90"></a>
<a name="line_91"></a>PK_subfields := table():
<a name="line_92"></a>
<a name="line_93"></a>######################################################################
<a name="line_94"></a>
<a name="line_95"></a>PK_subfields[ 1] := `new/PK_subfield`():
<a name="line_96"></a>PK_subfields[ 1]["stabiliser"] := [1];
<a name="line_97"></a>PK_subfields[ 1]["generating_sets"] := [[z,w],[t[0],u[0]]];
<a name="line_98"></a>CR := table():
<a name="line_99"></a>CR[1,2] := [z = t[0],w = u[0]];
<a name="line_100"></a>CR[2,1] := [t[0] = z,u[0] = w];
<a name="line_101"></a>PK_subfields[ 1]["conversion_rules"] := eval(CR):
<a name="line_102"></a>
<a name="line_103"></a>##################################################
<a name="line_104"></a>
<a name="line_105"></a>PK_subfields[ 2] := `new/PK_subfield`():
<a name="line_106"></a>PK_subfields[ 2]["stabiliser"] := [1,LL];
<a name="line_107"></a>PK_subfields[ 2]["generating_sets"] := [[z],[t[0]]];
<a name="line_108"></a>CR := table():
<a name="line_109"></a>CR[1,2] := [z = t[0]];
<a name="line_110"></a>CR[2,1] := [t[0] = z];
<a name="line_111"></a>PK_subfields[ 2]["conversion_rules"] := eval(CR):
<a name="line_112"></a>
<a name="line_113"></a>##################################################
<a name="line_114"></a>
<a name="line_115"></a>PK_subfields[ 3] := `new/PK_subfield`():
<a name="line_116"></a>PK_subfields[ 3]["stabiliser"] := [1,L,LL,LLL];
<a name="line_117"></a>PK_subfields[ 3]["generating_sets"] := [[t[1]]];
<a name="line_118"></a>CR := table():
<a name="line_119"></a>PK_subfields[ 3]["conversion_rules"] := eval(CR):
<a name="line_120"></a>
<a name="line_121"></a>##################################################
<a name="line_122"></a>
<a name="line_123"></a>PK_subfields[ 4] := `new/PK_subfield`():
<a name="line_124"></a>PK_subfields[ 4]["stabiliser"] := [1,M];
<a name="line_125"></a>PK_subfields[ 4]["generating_sets"] := [[t[2],u[1]],[t[2],v[1]]];
<a name="line_126"></a>CR := table():
<a name="line_127"></a>CR[1,2] := [t[2] = t[2],u[1] = -v[1]*t[2]^3/(2+t[2])];
<a name="line_128"></a>CR[2,1] := [t[2] = t[2],v[1] = -u[1]*(2+t[2])/t[2]^3];
<a name="line_129"></a>PK_subfields[ 4]["conversion_rules"] := eval(CR):
<a name="line_130"></a>
<a name="line_131"></a>##################################################
<a name="line_132"></a>
<a name="line_133"></a>PK_subfields[ 5] := `new/PK_subfield`():
<a name="line_134"></a>PK_subfields[ 5]["stabiliser"] := [1,LM];
<a name="line_135"></a>PK_subfields[ 5]["generating_sets"] := [[t[3],u[2]],[t[3],v[2]]];
<a name="line_136"></a>CR := table():
<a name="line_137"></a>CR[1,2] := [t[3] = t[3],u[2] = -(1-I)/sqrt(2)*v[2]*t[3]^3/(2+t[3])];
<a name="line_138"></a>CR[2,1] := [t[3] = t[3],v[2] = -(1+I)/sqrt(2)*u[2]*(2+t[3])/t[3]^3];
<a name="line_139"></a>PK_subfields[ 5]["conversion_rules"] := eval(CR):
<a name="line_140"></a>
<a name="line_141"></a>##################################################
<a name="line_142"></a>
<a name="line_143"></a>PK_subfields[ 6] := `new/PK_subfield`():
<a name="line_144"></a>PK_subfields[ 6]["stabiliser"] := [1,LLM];
<a name="line_145"></a>PK_subfields[ 6]["generating_sets"] := [[t[2],u[3]],[t[2],v[3]]];
<a name="line_146"></a>CR := table():
<a name="line_147"></a>CR[1,2] := [t[2] = t[2],u[3] = -I*v[3]*t[2]^3/(2-t[2])];
<a name="line_148"></a>CR[2,1] := [t[2] = t[2],v[3] =  I*u[3]*(2-t[2])/t[2]^3];
<a name="line_149"></a>PK_subfields[ 6]["conversion_rules"] := eval(CR):
<a name="line_150"></a>
<a name="line_151"></a>##################################################
<a name="line_152"></a>
<a name="line_153"></a>PK_subfields[ 7] := `new/PK_subfield`():
<a name="line_154"></a>PK_subfields[ 7]["stabiliser"] := [1,LLLM];
<a name="line_155"></a>PK_subfields[ 7]["generating_sets"] := [[t[3],u[4]],[t[3],v[4]]];
<a name="line_156"></a>CR := table():
<a name="line_157"></a>CR[1,2] := [t[3] = t[3],u[4] = -(1+I)/sqrt(2)*v[4]*t[3]^3/(2-t[3])];
<a name="line_158"></a>CR[2,1] := [t[3] = t[3],v[4] = -(1-I)/sqrt(2)*u[4]*(2-t[3])/t[3]^3];
<a name="line_159"></a>PK_subfields[ 7]["conversion_rules"] := eval(CR):
<a name="line_160"></a>
<a name="line_161"></a>##################################################
<a name="line_162"></a>
<a name="line_163"></a>PK_subfields[ 8] := `new/PK_subfield`():
<a name="line_164"></a>PK_subfields[ 8]["stabiliser"] := [1,LL,M,LLM];
<a name="line_165"></a>PK_subfields[ 8]["generating_sets"] := [[t[2]]];
<a name="line_166"></a>CR := table():
<a name="line_167"></a>PK_subfields[ 8]["conversion_rules"] := eval(CR):
<a name="line_168"></a>
<a name="line_169"></a>##################################################
<a name="line_170"></a>
<a name="line_171"></a>PK_subfields[ 9] := `new/PK_subfield`():
<a name="line_172"></a>PK_subfields[ 9]["stabiliser"] := [1,LL,LM,LLLM];
<a name="line_173"></a>PK_subfields[ 9]["generating_sets"] := [[t[3]]];
<a name="line_174"></a>CR := table():
<a name="line_175"></a>PK_subfields[ 9]["conversion_rules"] := eval(CR):
<a name="line_176"></a>
<a name="line_177"></a>##################################################
<a name="line_178"></a>
<a name="line_179"></a>PK_subfields[10] := `new/PK_subfield`():
<a name="line_180"></a>PK_subfields[10]["stabiliser"] := [1,L,LL,LLL,M,LM,LLM,LLLM];
<a name="line_181"></a>PK_subfields[10]["generating_sets"] := [[t[4]]];
<a name="line_182"></a>CR := table():
<a name="line_183"></a>PK_subfields[10]["conversion_rules"] := eval(CR):
<a name="line_184"></a>
<a name="line_185"></a>
<a name="line_186"></a>
  </pre>
 </body>
</html>
    